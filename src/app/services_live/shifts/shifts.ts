import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import * as API_CONFIG from '../api-config';
import { HTTP } from '@ionic-native/http/ngx';

@Injectable({
    providedIn: 'root'
})
export class ShiftsProvider {
    contentType: string;
    apiUrl: API_CONFIG.API;

    constructor(
        public http: HttpClient,
        private httpr: HTTP
    ) {
        this.apiUrl = API_CONFIG.API.URL;
        this.contentType = API_CONFIG.CONTENT_TYPE;
    }

    getWorkSched(date: string) {
        let headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            "Access-Control-Allow-Credentials" : "true",
        };

        let postParams = { 
            'date' : date
        };

        return new Promise((resolve, reject) => {
            this.httpr.post(this.apiUrl + '/api/work_schedule', postParams, headers)
            .then(data => {
                if (data.data) {
                    let a = JSON.parse(data.data);
                    resolve(a);
                }
            })
            .catch(error => {
                if (error.error) {
                    let e = JSON.parse(error.error);
                    reject(e);
                }
            });
        });
    }

    getNextSched(date: string) {
        let headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            "Access-Control-Allow-Credentials" : "true",
        };

        let postParams = { 
            'date' : date
        };

        return new Promise((resolve, reject) => {
            this.httpr.post(this.apiUrl + '/api/work_schedule/next_shift', postParams, headers)
            .then(data => {
                if (data.data) {
                    let a = JSON.parse(data.data);
                    resolve(a);
                }
            })
            .catch(error => {
                if (error.error) {
                    let e = JSON.parse(error.error);
                    reject(e);
                }
            });
        });
    }

    getScheduleTime(workschedId: string, date: string) {
        let headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            "Access-Control-Allow-Credentials" : "true",
        };

        let postParams = { 
            'work_schedule_id' : workschedId,
            'date_from' : date
        };

        return new Promise((resolve, reject) => {
            this.httpr.post(this.apiUrl + '/api/work_schedule/get_schedule_time', postParams, headers)
            .then(data => {
                if (data.data) {
                    let a = JSON.parse(data.data);
                    resolve(a);
                }
            })
            .catch(error => {
                if (error.error) {
                    let e = JSON.parse(error.error);
                    reject(e);
                }
            });
        });
    }

    getScheduleFrom(date: string) {
        let headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            "Access-Control-Allow-Credentials" : "true",
        };

        let postParams = { 
            'get_schedule' : "1",
            'date_from' : date
        };

        return new Promise((resolve, reject) => {
            this.httpr.post(this.apiUrl + '/api/work_schedule/get_schedule_from', postParams, headers)
            .then(data => {
                if (data.data) {
                    let a = JSON.parse(data.data);
                    resolve(a);
                }
            })
            .catch(error => {
                if (error.error) {
                    let e = JSON.parse(error.error);
                    reject(e);
                }
            });
        });
    }

    getWorkSchedules(date: string) {
        let headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            "Access-Control-Allow-Credentials" : "true",
        };

        let postParams = {
            'date_from' : date
        };

        return new Promise((resolve, reject)=> {
            this.httpr.post(this.apiUrl + '/api/work_schedule/get_work_schedule', postParams, headers)
            .then(data => {
                if (data.data) {
                    let a = JSON.parse(data.data);
                    resolve(a);
                }
            })
            .catch(error => {
                if (error.error) {
                    let e = JSON.parse(error.error);
                    reject(e);
                }
            });
        });
    }

    getServerDate() {
        return new Promise((resolve, reject) => {
            this.httpr.get(this.apiUrl + '/api/overtime/server_date', {}, {})
            .then(data => {
                if (data.data) {
                    let a = JSON.parse(data.data);
                    resolve(a);
                }
            })
            .catch(error => {
                if (error.error) {
                    let e = JSON.parse(error.error);
                    reject(e);
                }
            });
        });
    }

    requestWorkSched(wsid: any, startDate: any, endDate: any, startTime: any, endTime: any, reason: any, leaveStat: any) {
        
        let headers = {
            'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
            "Access-Control-Allow-Credentials" : "true",
        };

        let postParams = { 
            'schedule_change' : "1",
            'date_from' : startDate,
            'date_to' : endDate,
            'time_from' : startTime,
            'time_to' : endTime,
            'work_schedule_id' : wsid,
            'reason' : reason,
            'leaves_status' : leaveStat,
        };
        
        return new Promise((resolve, reject)=> {
            this.httpr.post(this.apiUrl + '/api/work_schedule/save_schedule', postParams, headers)
            .then(data => {
                if (data.data) {
                    let a = JSON.parse(data.data);
                    resolve(a);
                }
            })
            .catch(error => {
                if (error.error) {
                    let e = JSON.parse(error.error);
                    reject(e);
                }
            });
        });
    }
}
